/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface OvmCanonicalTransactionChainInterface extends ethers.utils.Interface {
  functions: {
    "L2_GAS_DISCOUNT_DIVISOR()": FunctionFragment;
    "MAX_ROLLUP_TX_SIZE()": FunctionFragment;
    "MIN_ROLLUP_TX_GAS()": FunctionFragment;
    "appendQueueBatch(uint256)": FunctionFragment;
    "appendSequencerBatch()": FunctionFragment;
    "batches()": FunctionFragment;
    "enqueue(address,uint256,bytes)": FunctionFragment;
    "forceInclusionPeriodBlocks()": FunctionFragment;
    "forceInclusionPeriodSeconds()": FunctionFragment;
    "getLastBlockNumber()": FunctionFragment;
    "getLastTimestamp()": FunctionFragment;
    "getNextQueueIndex()": FunctionFragment;
    "getNumPendingQueueElements()": FunctionFragment;
    "getQueueElement(uint256)": FunctionFragment;
    "getQueueLength()": FunctionFragment;
    "getTotalBatches()": FunctionFragment;
    "getTotalElements()": FunctionFragment;
    "libAddressManager()": FunctionFragment;
    "maxTransactionGasLimit()": FunctionFragment;
    "queue()": FunctionFragment;
    "resolve(string)": FunctionFragment;
    "verifyTransaction(tuple,tuple,tuple,tuple)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "L2_GAS_DISCOUNT_DIVISOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_ROLLUP_TX_SIZE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_ROLLUP_TX_GAS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "appendQueueBatch",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "appendSequencerBatch",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "batches", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "enqueue",
    values: [string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "forceInclusionPeriodBlocks",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "forceInclusionPeriodSeconds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLastBlockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLastTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNextQueueIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNumPendingQueueElements",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getQueueElement",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getQueueLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalBatches",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalElements",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "libAddressManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxTransactionGasLimit",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "queue", values?: undefined): string;
  encodeFunctionData(functionFragment: "resolve", values: [string]): string;
  encodeFunctionData(
    functionFragment: "verifyTransaction",
    values: [
      {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      { index: BigNumberish; siblings: BytesLike[] }
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "L2_GAS_DISCOUNT_DIVISOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_ROLLUP_TX_SIZE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_ROLLUP_TX_GAS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appendQueueBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appendSequencerBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "batches", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "enqueue", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forceInclusionPeriodBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceInclusionPeriodSeconds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastBlockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNextQueueIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNumPendingQueueElements",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getQueueElement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getQueueLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalBatches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalElements",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "libAddressManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxTransactionGasLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "queue", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resolve", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "verifyTransaction",
    data: BytesLike
  ): Result;

  events: {
    "QueueBatchAppended(uint256,uint256,uint256)": EventFragment;
    "SequencerBatchAppended(uint256,uint256,uint256)": EventFragment;
    "TransactionBatchAppended(uint256,bytes32,uint256,uint256,bytes)": EventFragment;
    "TransactionEnqueued(address,address,uint256,bytes,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "QueueBatchAppended"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SequencerBatchAppended"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionBatchAppended"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionEnqueued"): EventFragment;
}

export class OvmCanonicalTransactionChain extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: OvmCanonicalTransactionChainInterface;

  functions: {
    L2_GAS_DISCOUNT_DIVISOR(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "L2_GAS_DISCOUNT_DIVISOR()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    MAX_ROLLUP_TX_SIZE(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "MAX_ROLLUP_TX_SIZE()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    MIN_ROLLUP_TX_GAS(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "MIN_ROLLUP_TX_GAS()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    appendQueueBatch(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: void;
    }>;

    "appendQueueBatch(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: void;
    }>;

    appendSequencerBatch(overrides?: Overrides): Promise<ContractTransaction>;

    "appendSequencerBatch()"(
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    batches(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "batches()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    enqueue(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "enqueue(address,uint256,bytes)"(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    forceInclusionPeriodBlocks(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "forceInclusionPeriodBlocks()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    forceInclusionPeriodSeconds(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "forceInclusionPeriodSeconds()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    getLastBlockNumber(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "getLastBlockNumber()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    getLastTimestamp(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "getLastTimestamp()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    getNextQueueIndex(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "getNextQueueIndex()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    getNumPendingQueueElements(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "getNumPendingQueueElements()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    getQueueElement(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      _element: {
        transactionHash: string;
        timestamp: number;
        blockNumber: number;
        0: string;
        1: number;
        2: number;
      };
      0: {
        transactionHash: string;
        timestamp: number;
        blockNumber: number;
        0: string;
        1: number;
        2: number;
      };
    }>;

    "getQueueElement(uint256)"(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      _element: {
        transactionHash: string;
        timestamp: number;
        blockNumber: number;
        0: string;
        1: number;
        2: number;
      };
      0: {
        transactionHash: string;
        timestamp: number;
        blockNumber: number;
        0: string;
        1: number;
        2: number;
      };
    }>;

    getQueueLength(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "getQueueLength()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    getTotalBatches(
      overrides?: CallOverrides
    ): Promise<{
      _totalBatches: BigNumber;
      0: BigNumber;
    }>;

    "getTotalBatches()"(
      overrides?: CallOverrides
    ): Promise<{
      _totalBatches: BigNumber;
      0: BigNumber;
    }>;

    getTotalElements(
      overrides?: CallOverrides
    ): Promise<{
      _totalElements: BigNumber;
      0: BigNumber;
    }>;

    "getTotalElements()"(
      overrides?: CallOverrides
    ): Promise<{
      _totalElements: BigNumber;
      0: BigNumber;
    }>;

    libAddressManager(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "libAddressManager()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    maxTransactionGasLimit(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "maxTransactionGasLimit()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    queue(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "queue()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    resolve(
      _name: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "resolve(string)"(
      _name: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    verifyTransaction(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "verifyTransaction(tuple,tuple,tuple,tuple)"(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;
  };

  L2_GAS_DISCOUNT_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

  "L2_GAS_DISCOUNT_DIVISOR()"(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_ROLLUP_TX_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

  "MAX_ROLLUP_TX_SIZE()"(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_ROLLUP_TX_GAS(overrides?: CallOverrides): Promise<BigNumber>;

  "MIN_ROLLUP_TX_GAS()"(overrides?: CallOverrides): Promise<BigNumber>;

  appendQueueBatch(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  "appendQueueBatch(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  appendSequencerBatch(overrides?: Overrides): Promise<ContractTransaction>;

  "appendSequencerBatch()"(overrides?: Overrides): Promise<ContractTransaction>;

  batches(overrides?: CallOverrides): Promise<string>;

  "batches()"(overrides?: CallOverrides): Promise<string>;

  enqueue(
    _target: string,
    _gasLimit: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "enqueue(address,uint256,bytes)"(
    _target: string,
    _gasLimit: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  forceInclusionPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>;

  "forceInclusionPeriodBlocks()"(overrides?: CallOverrides): Promise<BigNumber>;

  forceInclusionPeriodSeconds(overrides?: CallOverrides): Promise<BigNumber>;

  "forceInclusionPeriodSeconds()"(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getLastBlockNumber(overrides?: CallOverrides): Promise<number>;

  "getLastBlockNumber()"(overrides?: CallOverrides): Promise<number>;

  getLastTimestamp(overrides?: CallOverrides): Promise<number>;

  "getLastTimestamp()"(overrides?: CallOverrides): Promise<number>;

  getNextQueueIndex(overrides?: CallOverrides): Promise<number>;

  "getNextQueueIndex()"(overrides?: CallOverrides): Promise<number>;

  getNumPendingQueueElements(overrides?: CallOverrides): Promise<number>;

  "getNumPendingQueueElements()"(overrides?: CallOverrides): Promise<number>;

  getQueueElement(
    _index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    transactionHash: string;
    timestamp: number;
    blockNumber: number;
    0: string;
    1: number;
    2: number;
  }>;

  "getQueueElement(uint256)"(
    _index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    transactionHash: string;
    timestamp: number;
    blockNumber: number;
    0: string;
    1: number;
    2: number;
  }>;

  getQueueLength(overrides?: CallOverrides): Promise<number>;

  "getQueueLength()"(overrides?: CallOverrides): Promise<number>;

  getTotalBatches(overrides?: CallOverrides): Promise<BigNumber>;

  "getTotalBatches()"(overrides?: CallOverrides): Promise<BigNumber>;

  getTotalElements(overrides?: CallOverrides): Promise<BigNumber>;

  "getTotalElements()"(overrides?: CallOverrides): Promise<BigNumber>;

  libAddressManager(overrides?: CallOverrides): Promise<string>;

  "libAddressManager()"(overrides?: CallOverrides): Promise<string>;

  maxTransactionGasLimit(overrides?: CallOverrides): Promise<BigNumber>;

  "maxTransactionGasLimit()"(overrides?: CallOverrides): Promise<BigNumber>;

  queue(overrides?: CallOverrides): Promise<string>;

  "queue()"(overrides?: CallOverrides): Promise<string>;

  resolve(_name: string, overrides?: CallOverrides): Promise<string>;

  "resolve(string)"(_name: string, overrides?: CallOverrides): Promise<string>;

  verifyTransaction(
    _transaction: {
      timestamp: BigNumberish;
      blockNumber: BigNumberish;
      l1QueueOrigin: BigNumberish;
      l1TxOrigin: string;
      entrypoint: string;
      gasLimit: BigNumberish;
      data: BytesLike;
    },
    _txChainElement: {
      isSequenced: boolean;
      queueIndex: BigNumberish;
      timestamp: BigNumberish;
      blockNumber: BigNumberish;
      txData: BytesLike;
    },
    _batchHeader: {
      batchIndex: BigNumberish;
      batchRoot: BytesLike;
      batchSize: BigNumberish;
      prevTotalElements: BigNumberish;
      extraData: BytesLike;
    },
    _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
    overrides?: CallOverrides
  ): Promise<boolean>;

  "verifyTransaction(tuple,tuple,tuple,tuple)"(
    _transaction: {
      timestamp: BigNumberish;
      blockNumber: BigNumberish;
      l1QueueOrigin: BigNumberish;
      l1TxOrigin: string;
      entrypoint: string;
      gasLimit: BigNumberish;
      data: BytesLike;
    },
    _txChainElement: {
      isSequenced: boolean;
      queueIndex: BigNumberish;
      timestamp: BigNumberish;
      blockNumber: BigNumberish;
      txData: BytesLike;
    },
    _batchHeader: {
      batchIndex: BigNumberish;
      batchRoot: BytesLike;
      batchSize: BigNumberish;
      prevTotalElements: BigNumberish;
      extraData: BytesLike;
    },
    _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    L2_GAS_DISCOUNT_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    "L2_GAS_DISCOUNT_DIVISOR()"(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_ROLLUP_TX_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    "MAX_ROLLUP_TX_SIZE()"(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_ROLLUP_TX_GAS(overrides?: CallOverrides): Promise<BigNumber>;

    "MIN_ROLLUP_TX_GAS()"(overrides?: CallOverrides): Promise<BigNumber>;

    appendQueueBatch(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "appendQueueBatch(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    appendSequencerBatch(overrides?: CallOverrides): Promise<void>;

    "appendSequencerBatch()"(overrides?: CallOverrides): Promise<void>;

    batches(overrides?: CallOverrides): Promise<string>;

    "batches()"(overrides?: CallOverrides): Promise<string>;

    enqueue(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "enqueue(address,uint256,bytes)"(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    forceInclusionPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    "forceInclusionPeriodBlocks()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    forceInclusionPeriodSeconds(overrides?: CallOverrides): Promise<BigNumber>;

    "forceInclusionPeriodSeconds()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLastBlockNumber(overrides?: CallOverrides): Promise<number>;

    "getLastBlockNumber()"(overrides?: CallOverrides): Promise<number>;

    getLastTimestamp(overrides?: CallOverrides): Promise<number>;

    "getLastTimestamp()"(overrides?: CallOverrides): Promise<number>;

    getNextQueueIndex(overrides?: CallOverrides): Promise<number>;

    "getNextQueueIndex()"(overrides?: CallOverrides): Promise<number>;

    getNumPendingQueueElements(overrides?: CallOverrides): Promise<number>;

    "getNumPendingQueueElements()"(overrides?: CallOverrides): Promise<number>;

    getQueueElement(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      transactionHash: string;
      timestamp: number;
      blockNumber: number;
      0: string;
      1: number;
      2: number;
    }>;

    "getQueueElement(uint256)"(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      transactionHash: string;
      timestamp: number;
      blockNumber: number;
      0: string;
      1: number;
      2: number;
    }>;

    getQueueLength(overrides?: CallOverrides): Promise<number>;

    "getQueueLength()"(overrides?: CallOverrides): Promise<number>;

    getTotalBatches(overrides?: CallOverrides): Promise<BigNumber>;

    "getTotalBatches()"(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalElements(overrides?: CallOverrides): Promise<BigNumber>;

    "getTotalElements()"(overrides?: CallOverrides): Promise<BigNumber>;

    libAddressManager(overrides?: CallOverrides): Promise<string>;

    "libAddressManager()"(overrides?: CallOverrides): Promise<string>;

    maxTransactionGasLimit(overrides?: CallOverrides): Promise<BigNumber>;

    "maxTransactionGasLimit()"(overrides?: CallOverrides): Promise<BigNumber>;

    queue(overrides?: CallOverrides): Promise<string>;

    "queue()"(overrides?: CallOverrides): Promise<string>;

    resolve(_name: string, overrides?: CallOverrides): Promise<string>;

    "resolve(string)"(
      _name: string,
      overrides?: CallOverrides
    ): Promise<string>;

    verifyTransaction(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<boolean>;

    "verifyTransaction(tuple,tuple,tuple,tuple)"(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    QueueBatchAppended(
      _startingQueueIndex: null,
      _numQueueElements: null,
      _totalElements: null
    ): EventFilter;

    SequencerBatchAppended(
      _startingQueueIndex: null,
      _numQueueElements: null,
      _totalElements: null
    ): EventFilter;

    TransactionBatchAppended(
      _batchIndex: BigNumberish | null,
      _batchRoot: null,
      _batchSize: null,
      _prevTotalElements: null,
      _extraData: null
    ): EventFilter;

    TransactionEnqueued(
      _l1TxOrigin: null,
      _target: null,
      _gasLimit: null,
      _data: null,
      _queueIndex: null,
      _timestamp: null
    ): EventFilter;
  };

  estimateGas: {
    L2_GAS_DISCOUNT_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    "L2_GAS_DISCOUNT_DIVISOR()"(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_ROLLUP_TX_SIZE(overrides?: CallOverrides): Promise<BigNumber>;

    "MAX_ROLLUP_TX_SIZE()"(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_ROLLUP_TX_GAS(overrides?: CallOverrides): Promise<BigNumber>;

    "MIN_ROLLUP_TX_GAS()"(overrides?: CallOverrides): Promise<BigNumber>;

    appendQueueBatch(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "appendQueueBatch(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    appendSequencerBatch(overrides?: Overrides): Promise<BigNumber>;

    "appendSequencerBatch()"(overrides?: Overrides): Promise<BigNumber>;

    batches(overrides?: CallOverrides): Promise<BigNumber>;

    "batches()"(overrides?: CallOverrides): Promise<BigNumber>;

    enqueue(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "enqueue(address,uint256,bytes)"(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    forceInclusionPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    "forceInclusionPeriodBlocks()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    forceInclusionPeriodSeconds(overrides?: CallOverrides): Promise<BigNumber>;

    "forceInclusionPeriodSeconds()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLastBlockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    "getLastBlockNumber()"(overrides?: CallOverrides): Promise<BigNumber>;

    getLastTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    "getLastTimestamp()"(overrides?: CallOverrides): Promise<BigNumber>;

    getNextQueueIndex(overrides?: CallOverrides): Promise<BigNumber>;

    "getNextQueueIndex()"(overrides?: CallOverrides): Promise<BigNumber>;

    getNumPendingQueueElements(overrides?: CallOverrides): Promise<BigNumber>;

    "getNumPendingQueueElements()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getQueueElement(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getQueueElement(uint256)"(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getQueueLength(overrides?: CallOverrides): Promise<BigNumber>;

    "getQueueLength()"(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalBatches(overrides?: CallOverrides): Promise<BigNumber>;

    "getTotalBatches()"(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalElements(overrides?: CallOverrides): Promise<BigNumber>;

    "getTotalElements()"(overrides?: CallOverrides): Promise<BigNumber>;

    libAddressManager(overrides?: CallOverrides): Promise<BigNumber>;

    "libAddressManager()"(overrides?: CallOverrides): Promise<BigNumber>;

    maxTransactionGasLimit(overrides?: CallOverrides): Promise<BigNumber>;

    "maxTransactionGasLimit()"(overrides?: CallOverrides): Promise<BigNumber>;

    queue(overrides?: CallOverrides): Promise<BigNumber>;

    "queue()"(overrides?: CallOverrides): Promise<BigNumber>;

    resolve(_name: string, overrides?: CallOverrides): Promise<BigNumber>;

    "resolve(string)"(
      _name: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyTransaction(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "verifyTransaction(tuple,tuple,tuple,tuple)"(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    L2_GAS_DISCOUNT_DIVISOR(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "L2_GAS_DISCOUNT_DIVISOR()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAX_ROLLUP_TX_SIZE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "MAX_ROLLUP_TX_SIZE()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MIN_ROLLUP_TX_GAS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "MIN_ROLLUP_TX_GAS()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    appendQueueBatch(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "appendQueueBatch(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    appendSequencerBatch(overrides?: Overrides): Promise<PopulatedTransaction>;

    "appendSequencerBatch()"(
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    batches(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "batches()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enqueue(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "enqueue(address,uint256,bytes)"(
      _target: string,
      _gasLimit: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    forceInclusionPeriodBlocks(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "forceInclusionPeriodBlocks()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    forceInclusionPeriodSeconds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "forceInclusionPeriodSeconds()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLastBlockNumber(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getLastBlockNumber()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLastTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getLastTimestamp()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextQueueIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getNextQueueIndex()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNumPendingQueueElements(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getNumPendingQueueElements()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getQueueElement(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getQueueElement(uint256)"(
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getQueueLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getQueueLength()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalBatches(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getTotalBatches()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalElements(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getTotalElements()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    libAddressManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "libAddressManager()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxTransactionGasLimit(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "maxTransactionGasLimit()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    queue(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "queue()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolve(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "resolve(string)"(
      _name: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyTransaction(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "verifyTransaction(tuple,tuple,tuple,tuple)"(
      _transaction: {
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        l1QueueOrigin: BigNumberish;
        l1TxOrigin: string;
        entrypoint: string;
        gasLimit: BigNumberish;
        data: BytesLike;
      },
      _txChainElement: {
        isSequenced: boolean;
        queueIndex: BigNumberish;
        timestamp: BigNumberish;
        blockNumber: BigNumberish;
        txData: BytesLike;
      },
      _batchHeader: {
        batchIndex: BigNumberish;
        batchRoot: BytesLike;
        batchSize: BigNumberish;
        prevTotalElements: BigNumberish;
        extraData: BytesLike;
      },
      _inclusionProof: { index: BigNumberish; siblings: BytesLike[] },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
